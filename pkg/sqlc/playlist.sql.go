// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: playlist.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const playlistCreate = `-- name: PlaylistCreate :one
INSERT INTO playlists (spotify_id, owner_id, name, description, public, tracks, collaborative)
VALUES ($1, $2, $3, $4, $5, $6, $7)
RETURNING id
`

type PlaylistCreateParams struct {
	SpotifyID     string
	OwnerID       int32
	Name          string
	Description   pgtype.Text
	Public        bool
	Tracks        int32
	Collaborative bool
}

func (q *Queries) PlaylistCreate(ctx context.Context, arg PlaylistCreateParams) (int32, error) {
	row := q.db.QueryRow(ctx, playlistCreate,
		arg.SpotifyID,
		arg.OwnerID,
		arg.Name,
		arg.Description,
		arg.Public,
		arg.Tracks,
		arg.Collaborative,
	)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const playlistDelete = `-- name: PlaylistDelete :exec
DELETE FROM playlists
WHERE id = $1
`

func (q *Queries) PlaylistDelete(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, playlistDelete, id)
	return err
}

const playlistGetAllWithOwner = `-- name: PlaylistGetAllWithOwner :many
SELECT p.id, p.spotify_id, p.owner_id, p.name, p.description, p.public, p.tracks, p.collaborative, p.updated_at, p.created_at, u.id, u.uid, u.name, u.display_name, u.email
FROM playlists p
LEFT JOIN users u ON u.id = p.owner_id
ORDER BY p.name
`

type PlaylistGetAllWithOwnerRow struct {
	Playlist Playlist
	User     User
}

func (q *Queries) PlaylistGetAllWithOwner(ctx context.Context) ([]PlaylistGetAllWithOwnerRow, error) {
	rows, err := q.db.Query(ctx, playlistGetAllWithOwner)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PlaylistGetAllWithOwnerRow
	for rows.Next() {
		var i PlaylistGetAllWithOwnerRow
		if err := rows.Scan(
			&i.Playlist.ID,
			&i.Playlist.SpotifyID,
			&i.Playlist.OwnerID,
			&i.Playlist.Name,
			&i.Playlist.Description,
			&i.Playlist.Public,
			&i.Playlist.Tracks,
			&i.Playlist.Collaborative,
			&i.Playlist.UpdatedAt,
			&i.Playlist.CreatedAt,
			&i.User.ID,
			&i.User.Uid,
			&i.User.Name,
			&i.User.DisplayName,
			&i.User.Email,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const playlistUpdate = `-- name: PlaylistUpdate :exec
UPDATE playlists
SET owner_id = $2, name = $3, description = $4, public = $5, tracks = $6, collaborative = $7, updated_at = NOW()
WHERE id = $1
`

type PlaylistUpdateParams struct {
	ID            int32
	OwnerID       int32
	Name          string
	Description   pgtype.Text
	Public        bool
	Tracks        int32
	Collaborative bool
}

func (q *Queries) PlaylistUpdate(ctx context.Context, arg PlaylistUpdateParams) error {
	_, err := q.db.Exec(ctx, playlistUpdate,
		arg.ID,
		arg.OwnerID,
		arg.Name,
		arg.Description,
		arg.Public,
		arg.Tracks,
		arg.Collaborative,
	)
	return err
}
